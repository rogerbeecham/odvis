---
output: github_document
---

```{r, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# odvis

[![R-CMD-check](https://github.com/rogerbeecham/odvis/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/rogerbeecham/odvis/actions/workflows/R-CMD-check.yaml)


`odvis` is an R package that provides helper functions for visualizing directed origin-destination data using `ggplot2`.  

## Installation

You can install the development version of `odvis` from [GitHub](https://github.com/) with:

``` {r, install_github, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
# install.packages("devtools")
devtools::install_github("rogerbeecham/odvis")
devtools::load_all()
library(tibble)
library(dplyr)
library(ggplot2)
library(ggforce)
library(purrr)
library(tidyr)
library(sf)
library(odvis)
```

## Asymmetric curves with `get_trajectory()`

Standard flow visualizations draw lines between origin-destination pairs. In `ggplot2` this can be achieved by passing coordinates to `geom_path()`, one row origin and destination respectively. In order to represent both outward and inward directions, we have had to offset the locations (y-position) of the coordinate pairs.


``` {r, straight-line-code, echo=TRUE, eval=FALSE}
od_pair <- tribble(
      ~direction, ~o_d,    ~x, ~y, 
       "out",        "origin",   0,  .2,   
       "out",        "destination",   1,  .2,
       "in",         "origin",   1,  -.2,
       "in",         "destination",   0,  -.2,
) 

od_pair |> 
  ggplot(aes(x=x, y=y, group=direction, colour=direction)) +
  geom_point() +
  geom_path()
```


``` {r, straight-line, echo=FALSE, eval=TRUE, warning=FALSE, message=FALSE}
od_pair <- tribble(
      ~direction, ~o_d,    ~x, ~y, 
       "out",        "origin",   0,  .2,   
       "out",        "destination",   1,  .2,
       "in",         "origin",   1,  -.2,
       "in",         "destination",   0,  -.2,
)      
     
od_pair |> 
  ggplot() +
  geom_point(aes(x=x, y=y*.2, group=direction, colour=direction)) +
  geom_path(aes(x=x, y=y*.2, group=direction, colour=direction)) +
  geom_text(aes(x=x, y=y*.5, label=o_d, colour=direction)) +
  geom_text(data=. %>% filter(o_d=="origin"), aes(x=.5, y=y, label=direction, colour=direction)) +
  scale_colour_manual(values=c("#b2182b", "#2166ac"), guide="none") +
  coord_equal(ylim=c(-.2, +.2), xlim=c(-.1, +1.1)) +
  theme_void()
```

The [`ggforce`](https://ggforce.data-imaginist.com/) extension provides a function for generating various curves, and we can use geom_bezier() to add a control point to offset curves depending on whether the direction is outward (bends upward) or inward (bends downward). This allows us to represent the origin and destination point locations in their exact position.

``` {r, bezier-line, echo=FALSE, eval=TRUE, warning=FALSE, message=FALSE}
od_pair <- tribble(
      ~direction, ~o_d,    ~x, ~y, 
       "out",        "o",   0,  .015,   
       "out",        "c",   0.5,  .2, 
       "out",        "d",   1,.015,
       "in",         "o",   1,  -.015,
       "in",        "c",   0.5,  -.2, 
       "in",         "d",   0,  -.015,
)      
     
od_pair |> 
  ggplot() +
  geom_point(data=. %>% filter(o_d!="c"), aes(x=x, y=0, group=direction)) +
  geom_bezier0(aes(x=x, y=y, group=direction, colour=direction)) +
  geom_text(data=. %>% filter(o_d!="c"), 
            aes(x=x, y=y*3, label=o_d, colour=direction)) +
  geom_text(data=. %>% filter(o_d=="o"), aes(x=.5, y=y*12, label=direction, colour=direction)) +
  scale_colour_manual(values=c("#b2182b", "#2166ac"), guide="none") +
  coord_equal(ylim=c(-.2, +.2), xlim=c(-.1, +1.1)) +
  theme_void()
```


A problem here is that the control point is not generalisable and the symbolisation not intuitive. The outward and inward directions are differentiated, but imagine a complex graph dataset with many edges connecting nodes in 2D space. So we move the control points such that lines curve towards the destination. This is achieved with `get_trajectory()`, which takes  a character string naming the od-pair and locations in x and y of that OD's origin an destination. The function returns a `tibble` of three rows representing, origin control point and destination respectively.  

``` {r, bezier-line-asymmetric, echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}
outward <- get_trajectory(o_x=0,o_y=0,d_x=1,d_y=0, "out") |>
  add_column(type=c("o","c","d"))
inward <- get_trajectory(o_x=1,o_y=0,d_x=0,d_y=0, "in") |> 
  add_column(type=c("o","c","d"))
dat <- bind_rows(outward, inward)

dat |> 
  ggplot(aes(x=x,y=y, colour=od_pair)) +
  geom_point(data=. %>% filter(type!="c"), colour="#252525") +
  ggforce::geom_bezier0(aes(group=od_pair)) +
   geom_text(data=. %>% filter(type=="c"), aes(label=od_pair)) +
  scale_colour_manual(values=c("#b2182b", "#2166ac"), guide="none") +
  coord_equal() +
  theme_void()
```

## Application 

``` {r, apply-bezier-line, echo=FALSE, eval=TRUE, warning=FALSE, message=FALSE}
trajectories <- bs_ods |> 
  filter(start_station_id!=end_station_id, count > 250) |> 
  mutate( id=row_number(), od_pair=paste0(start_station_id, "-", end_station_id)) |> 
  dplyr::select(-c(start_station_id, end_station_id, o_name, d_name, count)) |> 
  nest(data=c(od_pair, o_east, o_north, d_east, d_north)) |> 
  mutate(trajectory=
           map(data, 
               ~get_trajectory(.x$o_east, .x$o_north, .x$d_east, .x$d_north, .x$od_pair)
               )
         ) |> 
  select(trajectory) |> unnest(cols=trajectory)

dat <-
  tibble(
    od_pair="demo",
    o_east=0,
    d_east=1,
    o_north=1,
    d_north=1
  )

dat <- get_trajectory(dat$o_east, dat$o_north, dat$d_east, dat$d_north, dat$od_pair)
dat <- dat %>% mutate(row=row_number(),
                      type=if_else(row==1,"origin", if_else(row==2,"mid", "destination")))

legend <- ggplot() +
  geom_point(data=dat %>% filter(row!=2), aes(x=x, y=y), size=1, colour="#737373", alpha=0.5)+
  ggforce::geom_bezier0(data=dat, aes(x=x, y=y, group=od_pair), colour="#737373")+
  coord_equal()+
  geom_text(data=dat %>% filter(row!=2),
            aes(x=x, y=y-0.1, label=type), 
            colour="#252525", size=2.5, show.legend=FALSE, hjust="Middle", vjust="Top")+
  scale_x_continuous(limits=c(-0.1,1.3))+
  scale_y_continuous(limits=c(0.8,1.19))+
  theme_void()


bbox <- st_bbox(bs_villages)
width <- unname(bbox$xmax)-unname(bbox$xmin) 
height <- unname(bbox$ymax)-unname(bbox$ymin) 
aspect <- width/height

trajectories |> 
  left_join(
    bs_ods |> mutate(od_pair=paste0(start_station_id, "-", end_station_id)) |> 
      select(od_pair, count)
  ) |> 
  filter(count>100) |> 
  ungroup() |> 
  mutate(f_od=(count/max(count))^.4, count, max(count)) |> 
  ggplot() +
  geom_sf(data=bs_villages, fill="#f0f0f0",  colour="#bdbdbd", size=.2, alpha=.5)+
  geom_sf(data=rivers, fill="#d9d9d9",  colour="#d9d9d9")+
  ggforce::geom_bezier0(
     aes(x=x, y=y, group=od_pair, alpha=f_od, colour=f_od, linewidth=f_od)
     ) +
  coord_sf(crs=st_crs(bs_villages), datum=NA)+
  scale_colour_distiller(palette="Blues", direction=1, guide="none")+
  scale_linewidth_continuous(range=c(.3,1), guide="none") +
  scale_alpha(range=c(.3,1), guide="none") +
  theme_void() +
  annotation_custom(
    grob=ggplotGrob(legend),
    xmin=unname(bbox$xmin-+0.05*width),
    xmax=unname(bbox$xmin+0.2*width),
    ymin=unname(bbox$ymax)-0.1*height,
    ymax=unname(bbox$ymax)
  )
  
```


